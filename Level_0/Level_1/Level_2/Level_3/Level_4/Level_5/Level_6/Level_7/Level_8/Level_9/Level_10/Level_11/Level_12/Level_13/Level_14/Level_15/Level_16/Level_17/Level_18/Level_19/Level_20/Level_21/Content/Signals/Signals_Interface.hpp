// #ifndef SIGNALS_INTERFACE
// #define SIGNALS_INTERFACE


// namespace Universe
// {



//     // When a type is forward declared, all the compiler knows is that this type exists. It does not know its size, members or methods. This is why its
// 	// called incomplete type. Therefore, it can not be used to declare a variable, member or base class since the compiler would need the layout of the
// 	// type. In other words, it can not be used for anything that requires information on the specific type. What can be done is declaring pointer and
// 	// reference to the incomplete type. The pointer and refernce can act as a variable, argument to a method or as the return type.
// 	//
// 	// Forward declarations :
// 	//
// 	//  NONE
// 	//



// 	// Class Information :
// 	//
// 	//  Purpose :
// 	//
// 	//		Artifical Inteligence
// 	//
// 	//  Description :
// 	//
// 	//		1. The main purpose of an interface is to ensure that the group of objects which inherit from it, will be forced to implement some
// 	//		   functionality. The interface will only decalre some methods, without implementing them. The point is that all the inherting objects
// 	//		   will have to implement the lacking functionality. Methods that are only declared, and do not have implementation in the object, are
// 	//		   called pure virtual methods. The syntax for pure virtual methods is :
// 	//
// 	//				virtual void PureVirutalMethod( UnsignedInteger64bits number ) = 0;
// 	//
// 	//		   A pure virtual method means, that the object 'lacks' some part of the implementation, and therefore no instances of the object
// 	//		   can be created, because it is not a 'complete object'. Now, each object that inherits from it, will be forced to implement that
// 	//		   missing functionality, and instances of the inherting object can exist. As said above this is good to ensure a group of objects
// 	//		   implement some functionality, but it also gives the ability to point only to the 'interface part' of the object and use it without
// 	//		   actually knowing the exact type of the object. This is used, for example, to create containers of pointers to different objects,
// 	//		   that all inherit from the same object, and this is also valid to base objects that are not pure interfaces
// 	//
// 	// 		2. Encapsulation means that the user is only allowed to access certain parts of the object. Encapsulation is acheived in C++ by
// 	//		   providing 3 keywords :
// 	//
// 	//			1. Public - this part is for the user, it is the interface of the object. The user access and manipulate the data inside the
// 	//						obejct using the tools presented here. This part will usually contain only methods and not data members. If a data
// 	//						member is public all the encapsulation is lost, so it should be avoided in most cases
// 	//
// 	//			2. Protected - this part is for developing purposes, inheritance. A software developer can inherit from this object and it will
// 	//						   be able to access all the data and methods inside this part. This part will usually containt some methods and few
// 	//						   data members
// 	//
// 	//			3. Private - this part is for the developer of the object. This part will probably contain most of the data members of the object
// 	//						 and all the methods the developer needed to implement the interface presented in the public part. Every method in this
// 	//						 part will end with the suffix __Private
// 	//
// 	//  Expectations :
// 	//
// 	//		NONE
// 	//
// 	//  Possible errors :
// 	//
// 	//		Too many to count
// 	//
// 	template< typename SignalHandlerReturnType, typename... SignalHandlerArgumentTypes >
// 	class Signals_Interface
// 	{
// 	public:


// 		// Create a type definition for this object
// 		using SelfType = Signals_Interface< SignalHandlerSignatureType >;


// 		// This macro will be used to add all the infrastructure of an interface. All the methods will have the default behaviour generated by the compiler :
// 		//
// 		//		1. Defualt constructor
// 		//		2. Copy constructor
// 		//		3. Assignment operator
// 		//		4. Move constructor
// 		//		5. Move assignment operator
// 		//		6. Destructor
// 		//
// 		InterfaceInfrastructure_ForInheritance( Signals_Interface );


// 		// The following methods are the interface that each inherting object will have to implement :


// 		template< typename AsynchronosSignalHandler >
// 		virtual void SetAsynchronosSignalHandler( Signal signalToHandleAsynchronously, AsynchronosSignalHandler&& asynchronosSignalHandler ) = 0;


// 		virtual void WaitSynchronouslyForSignal( Signal signalToWaitFor ) = 0;


// 		virtual void WaitSynchronouslyForSignalUntilTimeIsOver( Signal signalToWaitFor, Time jsncjdn ) = 0;


// 		template< typename EntitiesToSendSignalIdentifierType >
// 		virtual SendSignalToSpecificEntity( Signal signalToSend, const EntitiesToSendSignalIdentifierType& entitiesToSendSignalTo ) = 0;


// 		virtual SetSignalsToActOn() = 0;

// 		virtual AddSignalsToIgnore() = 0;

// 		virtual AddSignalsToActOn() = 0;

// 		virtual GetSignalsWaitingForAction() = 0;

// 		// The following methods declare the overloaded operators for the object, which each inherting object will have to implement :


// 	};  //  Class Signals_Interface



// }  //  Namespace Universe



// #endif  // SIGNALS_INTERFACE_HPP