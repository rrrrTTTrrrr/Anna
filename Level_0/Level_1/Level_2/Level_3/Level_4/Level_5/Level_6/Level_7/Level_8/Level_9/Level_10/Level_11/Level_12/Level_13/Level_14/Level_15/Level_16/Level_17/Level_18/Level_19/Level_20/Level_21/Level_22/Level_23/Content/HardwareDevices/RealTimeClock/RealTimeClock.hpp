namespace Universe
{


namespace HardwareDevices
{



// https://wiki.osdev.org/CMOS#Getting_Current_Date_and_Time_from_RTC

// https://wiki.osdev.org/RTC

// https://stackoverflow.com/questions/49523916/out-of-bounds-rtc-output-in-real-mode-assembly

// https://www.oreilly.com/library/view/linux-device-drivers/0596000081/ch08s02.html



// Introduction :
//
// Have you ever thought how the computer is able to display the correct time after you power on the system? There is a component called
// 'Real Time Counter' in the computer which stores this date and time information when the computer is turned off.
//
// System clock and real time counter :
//
// Every computer includes a chip called Real Time Clock ( RTC ) which is independent of all the other chips and is used to maintain the
// time even when the system is powered off. The real time clock is actually a Motorola 146818 equivalent chip. It is sometimes called
// the CMOS clock because it comes with a static CMOS memory. The real time clock is driven by a bettery and maintains the current 'wall-clock'
// time when the computer is powered on or off. Besides the time keeping feature, the real time clock can generate different types of
// interrupts, which is connected to the IRQ 8 line of the programmable interrupt controller ( PIC ). This means that the interrupts 
// generated by the real time clock could be used to interrupt the CPU. For example operating system programmer can program the real 
// time clock to generate interrupts after a certain time interval and use this interrupt signal to make an operating system scheduler,
// although most of the operating system including Linux use another chip called the programmable interval timer ( PIT ) for this
// purpose. In Linux the real time clock is used to derive the system time during bootup ( if it does not derive the current time from
// some other device, for example over the network ).
//
// Access real time clock through shell tools :
//
// To know what the real time clock tells about the time exist the tool - hwclock. To get what is stored in the real time clock hardware
// clock execute as superuser :
//
//		sudo hwclock -r
//
// To set the hardware clock to some date and time :
//
//		sudo hwclock --set --date="1/1/34 18:00:00"
//
// Accessing the real time clock through Linux :
//
// Linux provides an interface to the real time clock through the device '/dev/rtc' with the help of 'ioctl' interface. The set of
// requests which can be performed on the real time clock through the ioctl interface is defined in the file 'linux/rtc.h'.
//
// First the device file needs to be open '/dev/rtc' to get a valid file descriptor. To read the time the file descriptor needs to
// be passed to the ioctl's first parameter. The second parameter is the request that the real time clock driver should perform. For
// example to read the time the request is 'RTC_RD_TIME'. The third parameter for this request requires to pass and address to a
// structure 'rtc_time' ( defined in linux/rtc.h ). This will fillup the structure with the date and time values. Similarly, to write
// to the real time clock, first initialize an 'rtc_time' structure with the appropriate values and then oass it to ioctl with the 
// request 'RTC_SET_TIME'. The structure is defined as follows :
//
//		struct rtc_time 
//		{
//			int tm_sec;		// [0-60]
//			int tm_min; 	// [0-59]
//			int tm_hour;	// [0-23]
//			int tm_mday;	// [1-31]
//			int tm_mon;		// [0-11]
//			int tm_year;	// Years since 1900
//			int tm_wday;	// Unused
//			int tm_yday;	// Unused
//			int tm_isdst; 	// Unused
//		}
//
// The year's field values returned is relative to some fixed year. Most of the cases it is 1900, but it can vary in some systems. To
// know the exact base value, it needs to be fetched using the 'EPOCH_READ' request, storing it in an 'unsigned long int' in the third
// parameter.
//
// And now its time for some code :
//
// 		#include <time.h>
// 		#include <sys/time.h>
// 		#include <sys/ioctl.h>
// 		#include <stdio.h>
// 		#include <stdlib.h>
// 		#include <fcntl.h>
// 		#include    <linux/rtc.h>
// 		#include    <linux/ioctl.h>
// 		#include <unistd.h>
//		 
// 		//Static epoch value
// 		#define EPOCH 1900
//		 
// 		int
// 		cmos_read_time (struct rtc_time *rtc)
// 		{
// 		  int rtc_fd;
// 		  int epoch, retval;
//		 
// 		  rtc_fd = open ("/dev/rtc", O_RDONLY);
// 		  if (rtc_fd == -1)
// 		    return 1;
//		 
// 		  retval = ioctl(rtc_fd, RTC_RD_TIME, rtc);
// 		  if (retval == -1)
// 		    return 1;
//		 
// 		  retval = ioctl(rtc_fd, RTC_EPOCH_READ, &epoch);
// 		  if (retval == -1)
// 		  {
// 		    perror ("ERROR");
// 		    printf ("Setting epoch to default\n");
// 		    epoch = EPOCH;
// 		  }
//		 
// 		  close (rtc_fd);
// 		  return 0;
// 		}
//		 
// 		int
// 		cmos_write_time (struct rtc_time *rtc)
// 		{
// 		  int rtc_fd, retval;
//		 
// 		  rtc_fd = open ("/dev/rtc", O_RDONLY);
// 		  if (rtc_fd == -1)
// 		    return 1;
//		 
// 		  retval = ioctl(rtc_fd, RTC_SET_TIME, rtc);
// 		  if (retval == -1)
// 		    return 1;
//		 
// 		  close (rtc_fd);
// 		  return 0;
// 		}
//		 
// 		int
// 		main (void)
// 		{
// 		  struct rtc_time time;
// 		  int retval;
//		 
// 		  char *month_string[] =
// 		  {
// 		    "January"   , "February", "March"    , "April"    ,
// 		    "May"       , "June"    , "July"     , "August"   ,
// 		    "September" , "October" , "November" , "December"
// 		  };
//		 
// 		  retval = cmos_read_time (&time);
// 		  if (retval != 0)
// 		    {
// 		      perror ("quit");
// 		      exit (1);
// 		    }
//		 
// 		  printf ("\nDay      : %02d", time.tm_mday);
// 		  printf ("\nMonth    : %02d   : %s", time.tm_mon + 1, month_string[time.tm_mon]);
// 		  printf ("\nYear     : %02d", time.tm_year + 1900);
// 		  printf ("\n");
// 		  printf ("\nHour     : %02d", time.tm_hour);
// 		  printf ("\nMin      : %02d", time.tm_min);
// 		  printf ("\nSec      : %02d", time.tm_sec);
//		 
// 		  if (retval != 0)
// 		  {
// 		    perror ("quit");
// 		    exit (1);
// 		  }
// 		  printf ("\n");
// 		  return 0;
// 		}
//
// Going lower :
//
// So far the Linux real time clock interface was used. In this section a step lower is taken, to show how to access and do the same
// above operations by accessing the real time clock device directly through the input output port. 
//
// To communicate with the real time clock the external port mappings of the real time clock needs to be knwon, as well as the internal
// register mappings. There are two ports which are used to talk to the real time clock. The address port 0x70 and the data port 0x71.
// There are many internal registers associated with the real time clock ( the CMOS memory ) some are read only and some are read write.
// To read or write data from the real time clock, the specific register needs to be located. Each register has an address. The port 
// mapping and the internal register addresses are displayed in the following tables :
//
// Table 1 - real time clock address and data port mappings :
//
//		Port 		Use
//
//		0x70		Address port
//		0x71		Data port
//
// Table 2 - mapping of real time clock internal registers :
//
//		Internal address   			Value stored
//
//		0x00 						Current time seconds
//		0x01 						Alarm seconds
//		0x02 						Current time minutes
//		0x03 						Alarm minutes
//		0x04 						Current time hours
//		0x05 						Alarm hours
//		0x06 						Day of week ( Sunday = 1 )
//		0x07 						Data of month
//		0x08 						Month
//		0x09 						Year ( The last two digits )
//		0x32 						Current century ( The first two year digits )
//		0x0A 						Status register A
//		0x0B 						Status register B
//
// Table 3 - the bit interpretations of status register B :
//
//		Bit position 				Interpretation
//
//		7 							Enable cycle update
//		6 							Enable periodic interrupt
//		5 							Enable alarm interrupt
//		4 							Enable update end interrupt
//		3 							Enable square wave output
//		2 							Date mode : 0 - binary coded decimal ( BCD ) / 1 - Binary
//		1 							12/24 hour mode : 0 - 12 hour / 1 - 24 hour
//		0 							Day light saving enabled : 1 enabled / 0 disabled
//
// In register A the only relevant bit is bit 7, the UIP bit that denotes if an update cycle is in progress. The time information is
// updated every second. In the middle of a time update the data could be inconsistent. The bit 7 of register B is also intresting in
// this matter. When this bit is set to 0 real time clock is going through a normal update cycle, that is, it's advancing counts once
// per second. Writing time into the real time clock during such an update can occur in the middle of a cycle update, which is undesired.
// If this bit is set to 1 then any update cycle in progress is aborted after, then the date time can be writtn to the real time clock
// without worrying that an update will cause inconsistent data. And after the bit can be set to 0, to return the normal update cycle.
//
// Communicating ( read and write ) :
//
// Communicating with the real time clock is simply reading and writing from the real time clock different registers. The previous
// section describes the input and output port mapping of the real time clock and the internal register mappings and the status
// register bit interpretations.
//
// Reading from or writing to the real time clock needs two steps. The steps are :
//
//	1. The first step is to notify the real time clock which of the internal registers is needed. This is done by sending the address
//	   of the register to be read or written to port 0x70. This selects the register
//	2. Now that the required internal register is selected. Read and write is done from port 0x71. Read from port 0x71 will set a byte
// 	   in the required register. Write a byte into port 0x71, and the value will overwrite the value in the internal register
//
// To read from the ports the functions in the header 'sys/io.h' can be used. To read from a port the function 'inb' can be used. To
// write a byte to a port 'outb' can be used. 'inb' takes one argument, the port address from which it reads the required byte. The
// 'outb' function has two arguments, the first one specifies the value to be written and the second argument tells the port number
// to be written into. For example :
//
//		val = inb( 0x71 )  and  outb( val, 0x70 )
//
// Note, once value was written to port 0x70 then read or write from 0x71 should be done, otherwise an undefined behaviour can occur.
// Furthermore, it is a good practice to wait for some time before reading or writing from port 0x71, after the request to 0x70, to 
// ensure that the component had the time to set the data.
//
// Permissions :
//
// Sufficient permission is required to access the ports directly when working above an operating system, which disallow direct access
// to certain memory ranges. To enable access to the required input output ports the 'ioperm' function can be used :
//
//		ioperm( 0x70, 0x01, 3 )



// Real time clock :
//
// A typical operating system will use the APIC or PIT for timing purposes. However the real time clock works just as well. It is the
// chip that keeps the computer's clock up to date. Within the chip is also the 64 bytes of CMOS random access memory.
//
// The real time clock is capable of multiple frequencies. The base frequency is pre programmed at 32.768 kHZ. It is possible to change
// this value, but this is the only base frequency that will keep proper time. For this reason, it is strongly recommended not to change
// the base frequency. The chi also has a "divider" register that will generate other frequencies from the base frequency. The output
// (interrupt) divider frequency is by default set so that there is an interrupt rate of 1024 Hz. The real time clock can theoretically
// generate 15 interrupt rates between 2 Hz and 32768 Hz. On most machines however, the real time clock interrupts rate can not go
// higher than 8 kHz.
// 
// Real time clock interrupts are disabled by default. If the real time clock interrupts are turned on, the real time clock will 
// periodically generate IRQ 8.
//
// Avoiding non maskable interrupt (NMI) and other interrupts while programming :
//
// When programming the real time clock, it is extremely imperative that the non maskable interrupt and other interrupts are disbaled.
// This is because if an interrupt happens, the real time clock may be left in an "undefined" (non functional) state. This would usually
// not be too big a deal, except for two things. The real time clock is never initialized by the BIOS, and it is backed up with a 
// battery. So even a cold reboot may not be enough to get the real time clock out of an undefined state!
//
// Setting the registers :
// 
// The 2 input and output ports used for the real time clock and CMOS are 0x70 and 0x71. Port 0x70 is used to specify an index or
// "register number", and to disable non maskable interrupt. Port 0x71 is used to read or write from or to that byte of CMOS 
// configuration space. Only three bytes of CMOS random access memory are used to control the real time clock periodic interrupt
// function. They are called real time clock status register A, B and C. They are at offset 0xA, 0xB in the CMOS random access
// memory. To write 0x20 to status register A the syntax is as follows :
//
// 		disable_ints();				// Important that no interrupts happen
//		outportb( 0x70, 0x8A );		// Select status register A, and disable non maskable interrupts (by setting the 0x80 bit)
//		outportb( 0x71, 0x20 );		// Write to real time clock or CMOS random access memory
//		enable_ints();				// Reenable non maskable interrupts
//
// Other bytes of the CMOS ranodm access memory are used by the real time clock for other functions, or by the BIOS and other such
// services.
//
// Interrupt request (IRQ) danger :
//
// Since the interrupt request number is 8 for the real time clock, it has a lower priority in the PIC than the interrupt requests
// with lower numbers. While those other interrupts are being handled (until the operating system sends an EOI and STI), the operating
// system will not receive any clock ticks. Any interrupt request handlers that depend on clock ticks may fail for that reason,
// because an interrupt request of higher number will not preempt an interrupt request of lower number.
//
// Turning on interrupt request 8 :
//
// To turn the periodic interrupt, the syntax is as follows :
//
// 		disable_ints();								// Important that no interrupts happen
//		outportb( 0x70, 0x8B );						// Select status register B, and disable non maskable interrupts (by setting the 0x80 bit)
//		char previousValue = inportb( 0x71 );		// Read the current value of register B
//		outportb( 0x70, 0x8B );						// Set the index again (a read will reset the index to register D)
//		outportb( 0x71, previousValue | 0x40 );		// Perform an OR between the previous value and 0x40, and write the result. This turns on bit 6 of register B
//		enable_ints();								// Reenable non maskable interrupts
//
// This will turn on the interrupt request with the default 1024 Hz rate. Install the interrupt request handler before enbaling it!
//
// Changing interrupt rate :
//
// Changing the output divider changes the interrupt rate, without interfering with the real time clock ability to keep proper time.
// The lower 4 bits of register A is the divider value. The default is 6 ( in binary 0110 ). The setting must be a value from 1 to 15. 
// A value of 0 disables the interrupt. To calculate a new frequency :
//
//		frequency = 32768 >> ( rate - 1 )
//
// "Rate" is the divider setting. If a rate is selected of 1 or 2, the real time clock will have problems and "roll over" so that it
// generates interrupts of .81 ms and 3.91 ms, rather than the expected interrupts of 61.0 us or 30.5 us. So, the fastest rate that
// should be selected if 3. The will generate interrupts of 8 kHz or 122 us. To change the rate :
//
//		rate &= 0x0F;												// Rate must be above 2 and lower than 16
// 		disable_ints();												// Important that no interrupts happen
//		outportb( 0x70, 0x8A );										// Set index to register A, disble non maskable interrupts
//		char previousValue = inportb( 0x71 );						// Get initial value of register A
//		outportb( 0x70, 0x8A );										// Reset index to A
//		outportb( 0x71, ( ( previousValue & 0xF0 ) | rate ) ); 		// Write only the required rate to A. Note, rate is the bottom 4 bits
//		enable_ints();												// Reenable non maskable interrupts
//
// Interrupts and register C :
//
// It is important to know that upon a interrupt request 8, status register C will contain a bitmask telling which interrupt happened.
// The real time clock is capable of producing a periodic interrupt, an update ended interrupt and an alarm interrupt. What is important
// that if register C is not read after an interrupt request 8, then the interrupt will not happen again. So, even if the type of 
// interrupt is not required, the register still needs to be read. The syntax is as follows :
//
//		outportb( 0x70, 0x0C );		// Select register C
//		inportb( 0x71 ); 			// Read the content of register C



// CMOS :
//
// "CMOS" is a tiny bit of very low power static memory that lives on the same chip as the real time clock. CMOS and the real time clock
// can only be accessed through input and output ports 0x70 and 0x71. The function of the CMOS memory is to store 50 (or 114) bytes of
// "setup" informaion for the BIOS while the computer is turned off, because there is a separate battery that keeps the clock and CMOS
// information active.
//
// CMOS values are accessed a byte at a time, and each byte is individually addressable. Each CMOS addres is traditionalyy called a 
// "register". The first 14 CMOS registers access and control the real time clock. In fact, the only truly useful registers remaining
// in CMOS are the real time clock registers, and register 0x10. All other registers in CMOS are almost entirely obsolete (or are not
// standardized), and are therefore useless.
//
// Non maskable interrupts :
//
// For frugality in the olden days, many functions were merged togethere on chips where there was "room", even if they did not belong
// together. This is how the "disable non maskable interrupts" control was put together with the CMOS controller and the real time clock.
// 
// Non maskable interrupts are meant to communicate a "panic" status from the hardware to the central processing unit in a way that
// the central processing unit can not ignore. It is typically used to signal memory errors.
//
// Whenever a byte is sent to input and output port 0x70, the high order bit tells the hardware whether to disable non maskable 
// interrupts from reaching the central processing unit. If the bit is on, non maskable interrupts are disabled (until the next
// time a byte is sent to port 0x70). The low order 7 bits of any byte sent to port 0x70 are used to address CMOS registers.
//
// CMOS registers :
//
// Accessing CMOS registers is extremely simple, but how to handle non maskable interrupts always needs to be taken into account.
// First a CMOS register is selected (for reading or writing) by sending the register number to input and output port 0x70. Since
// the high order bit of port 0x70 controls non maskable interrupts, it always needs to be set with state. This way the CMOS
// controller always needs to know whether the operating system wants non maskable interrupts enabled or not. Selecting CMOS 
// register is done as follows :
//
//		outb( 0x70, ( NMI_dsiable_bit << 7 ) | ( CMOS register index ) );
//
// Once a register is selected, write ('out' assembly instruction) or read ('in' assembly instruction) from that register can be
// done using port 0x71 :
//
//		val_8bit = inb( 0x71 );
//
// The required CMOS register needs to be selected each time, after each read or write the default is set back again to 0xD. Also
// it is probably a good idea to have a reasonable delay after selecting a CMOS register on port 0x70, before reading or writing
// the value on port 0x71.
//
// Checksums :
//
// The proper functioning of the BIOS during bootup depends on the values in CMOS. So the values are protected against random
// changes with checksums. It is very unwise ever to write a value into any of the CMOS registers (except for the real time clock),
// because when a value is changed the BIOS specific checksum needs to be fixed in a different register, or else the next boot
// will crash with an 'invalid checksum' error. And since the checksum is located at a proprietary BIOS specific register number,
// good luck finding it:)
//
// Register 0x10 :
//
// This register contains the only CMOS value that an operating system might ever find to be useful. It describes the "type" of
// each of the two floppy drives that may be attached to the system. The high nibble describes the "master" floppy drive on the
// primary bus, and the low nibble has an identical description for the "slave" floppy drive.
//
// Value of each 4 bit nibble, and associated floppy drive type :
//
//		Value      Drive Type
//
//		 0x00		No drive
//		 0x01 		360 KB 5.25 Drive
//		 0x02 		1.2 MB 5.25 Drive
//		 0x03 		720 KB 3.5 Drive
//		 0x04 		1.44 MB 3.5 Drive
//		 0x05 		2.88 MB 3.5 Drive
//
// The real time clock :
//
// The real time clock keeps track if the date and time, even when the computer's power is off. The only other way that a computer
// used to be able to do this was to ask a human for the data and time on every bootup. Now, if the computer has an internet connection,
// an operating system has another (much better) way to get the same information.
//
// The real time clock also can generate clock ticks on interrupt request 8 (similarly to what the PIT does on interrupt request 0). The
// highest feasible clock frequency is 8 kHz. Using the real time clock this way may actually generate more stable clock pulses than the
// PIT can generate. It also frees up the PIT for timing events that really need near microsecond accuracy. Additionally, the real time
// clock can generate an interrupt request 8 at a particular time of day.
//
// Getting current data and time from the real time clock :
//
// To get each of the following date and time values from the real time clock, a check that an update is not in progress needs to be done.
// Then the CMOS register can be selected, and the value read in the way descrived above.
//
//		Register 		Contents 			Range
//
//		  0x00 			Seconds    			0-59
//		  0x02 			Minutes    			0-59
//		  0x04 			Hours    			0-23 -> in 24 hour mode, and 1-12 -> in 12 hour mode, highest bit set if pm
//
//		  0x06 			Weekday    			1-7, Sunday == 1
//		  0x07 			Day of month		1-31
//		  0x08 			Month    			1-12
//		  0x09 			Year    			0-99
//		  0x32 			Century    			19-20
//
//		  0x0A 			Status register A
//		  0x0B 			Status register B
//
// Century register :
//
// Originally the real time clock did not have a century register at all. In the 1990s (as the year 2000 got closer) hardware manufacturers
// started realising that this might become a probelm. They start adding century registers to thier real time clocks. Unfortunately, there
// was no official standard to follow, different manufacturers used different registers.
//
// This meant that software didn't know if there was a century register, and which register it might be. To fix that problem the ACPI 
// specification included a real time clock century register field at offset 108 in its 'Fixed ACPI description table'. If this field
// contains zero then the real time clock doesn't have a century register, and if the field is non-zero then it contains the number of
// real time clock register to use for the century.
//
// If there si no century register then software can guess. For example, a piece of software written in 1990 can use the 2 digit year register
// to determine the most likely century. If the real time clock year register is higher than or equal to 90 then the year is probably '19YY'
// and if the real time clock year register is less than 90 the year must be '200YY'. In this way, software can correctly determine the 
// century for up to 99 years after the software is written.
//
// Century register as time and date sanity check :
//
// If the CMOS or real time clock has a century register, and the software used was released in 2014, and the century register shows the
// year 2008, then obviously the real time clock is wrong.
//
// Essentially, the method for guessing the century when there is no century register is much more reliable than the real time clock century
// register, if it exists. This means that the century register can be used in reverse, as a way to check if the real time counter time and
// date are sane, or if the real time clock has a flat battery or other problem.
//
// Weekday register :
//
// The real time clock chip is able to keep track of the current day of the week. All it does in increment its 'weekday' register at 
// midnight and reset it to 1 if the incremented value would go above 7. Unfortunately there is no guarantee that this register was
// ever set correctly by anything (including when the user changes the time and date using the BIOS configuration screen). It is
// entirely unreliable and should not be used. The correct way to determine the current day of the week is to calculate it from the
// date.
//
// Real time clock update in progress :
//
// When the chip updates the time and date (once per second) it increases the 'seconds' and checks if it rolled over. If 'seconds' did roll
// over it increases 'minutes' and checks if that rolled over. This can continue through all the time and date registers. However, the 
// real time clock circuitry is typically relatively slow. This means that it's entirely possible to read the time and date while an update
// is in progress and get dodgy or inconsistent values.
//
// To help guard against this problem the real time clock has an 'update in progress' flag (bit 7 of status register A). To read the time 
// and date properly, the software needs to wait until this flag goes from "set" to "clear". This is not the same as checking that the 
// 'update in progress' flag is clear.
//
// For example, if the code checks :
//
//		while ( updateInProgressFlag != clear )
//		{
//			...
//		}
//
// and then starts reading all the time and date registers, then the update could begin immediately after the flag was checked and the 
// code still read dodgy or inconsistent values. To avoid this, code should wait until the flag becoms set and then wait until the flag
// becomes clear. That way there's almost 1 second of time to read all the registers correctly.
//
// Unfortunately, doing it correctly is very slow, it may take an entire second of waiting or polling before the registers can be read,
// there are 2 alternatives.
//
// The first alternative is to rely on the 'u[date interrupt' When the real time clock finishes an update it generates an 'update'
// interrupt' (if it is enabled), and the interrupt request handler can safely read the time and date registers without worrying about 
// the update at all, as long as the interrupt request handler does the job in less than one second. In this case the central processing
// unit does not waste one second of waiting or polling, but it may still take a full second before the time and date has been read.
// Despite this it can be a useful technique during operating system boot. Setup the 'update interrupt' and it interrupt request handler
// as early as possible and then make the code do other things, in hope the the handler will finish before the time or date is neeeded.
//
// The second alternative is to be prepared for dodgy or inconsistent values and cope with them if they occur. To do this, the code 
// should check that an update is not in progress, than read all the time and date registers, then check that an update is 
// still not in progress, and finally read all the time and date registers again. If the values that were read the first time are the
// same as kthe values that were read the second time then the values must be correct. If any of the values are different it needs
// to be done again, until the values are the same.
//
// Format of bytes :
//
// There are 4 formats possible for the date and time of the real time clock bytes :
//
//		* Binary or binary coded decimal mode
//		* Hours in 12 hour format or 24 hour format
//
// The format is controlled by the status register B. On some real time clock chips, the format bits in status register B cannot be 
// changed. So the code needs to be able to handle all four possibilities, and and it should not try to modify status register B's
// settings. Status register B content then always needs to be read first to find out what format the date and time bytes use.
//
//		* Status register B, bit 1 on: enables 24 hour format , otherwise 12 hour format
//		* Status register B, bit 2 on: enables binary format , otherwise binary coded decimal format
//
// Binary mode is the normal operation. If the time is 1:33:10 AM, then the value of hours would be 1 = 0x01, minutes would be 33 = 0x21, and 
// seconds would be 10 = 0x0A.
//
// In binary coded decimal mode, each of the two hex nibbles of the byte is modified to "disaply" a decimal number. So for the time 1:33:10 AM, the hours
// will contain 0x01, minutes = 0x33, seconds = 0x10. The values needs to be converted to binary.
//
// 24 hour time means hour 0 is midnight and hour 23 is 11 PM. 12 hour time is a bit more tricky. If the hour is PM, then the high most
// significant bit is set on the hour byte



// Linux prevents access to input and output ports. Therefore the 'ioperm' system call must be used to get permission to perform input
// and output operations. For the real time clock the call needs to be :
//
//      ioperm( 0x70, 2, 1 )



// Class Information :
//
//  Purpose :
//
//		Artifical Inteligence
//
//  Description :
//
//		1. This object is used only to wrap some static methods, which can be used without any instance of the object
//
//		2. This object has all the methods to create, destory, copy and move disabled to ensure that no instances of it will be created
//
// 		3. Encapsulation means that the user is only allowed to access certain parts of the object. Encapsulation is acheived in C++ by
//		   providing 3 keywords :
//
//			1. Public - this part is for the user, it is the interface of the object. The user access and manipulate the data inside the
//						obejct using the tools presented here. This part will usually contain only methods and not data members. If a data
//						member is public all the encapsulation is lost, so it should be avoided in most cases
//
//			2. Protected - this part is for developing purposes, inheritance. A developer can inherit from this object and it will
//						   be able to access all the data and methods inside this part. This part will usually containt some methods and few
//						   data members
//
//			3. Private - this part is for the developer of the object. This part will probably contain most of the data members of the object
//						 and all the methods the developer needed to implement the interface presented in the public part. Every method in this
//						 part will end with the suffix __Private
//
//  Expectations :
//
//      1. The real time clock hardware device exist
//      2.
//
//  Possible errors :
//
//		Too many to count
//
class RealTimeClock NotForInheritance
{
public:


	// Create a type definition for this object
	using SelfType = RealTimeClock;


	// The following functions are declared static. Static functions do not belong to any of the instances, but rather to the object.
	// Satic functions only have access to static data members, which also don't belong to any instance, this means all other data members
	// can not be used. The only purpose then of declaring a static function is when a private static data member needs to be manipulated,
	// or some functionality needed that does not involve the non static data members


	// Method Information :
	//
	//  Description :
	//
	//		Use this method to get a time stamp
	//
	//  Required arguments :
	//
	//		User information needed :
	//
	//			1. second - a reference to a byte that will store the value read for the seconds part of the time
    //          2. minute - a reference to a byte that will store the value read for the minutes part of the time
    //          3. hour - a reference to a byte that will store the value read for the hour part of the time
	//
	//		Information returned to the user :
	//
	//			NONE
	//
	//  Return value :
	//
	//		NONE
	//
	//  Expectations :
	//
    //      NONE
	//
	//  Possible errors :
	//
	//		NONE
	//
	static void TimeStamp( UnsignedInteger8bits& second, UnsignedInteger8bits& minute, UnsignedInteger8bits& hour );


	// Method Information :
	//
	//  Description :
	//
	//		Use this method to get a date stamp
	//
	//  Required arguments :
	//
	//		User information needed :
	//
    //          1. dayOfMonth - a reference to a byte that will store the value read for the day of month part of the date
    //          2. month - a reference to a byte that will store the value read for the month part of the date
    //          3. absoluteYearSinceTheBirthOfJisus - a reference to two bytes that will store the value read for the year part of the date
	//
	//		Information returned to the user :
	//
	//			NONE
	//
	//  Return value :
	//
	//		NONE
	//
	//  Expectations :
	//
    //      NONE
	//
	//  Possible errors :
	//
	//		NONE
	//
	static void DateStamp( UnsignedInteger8bits& dayOfMonth, UnsignedInteger8bits& month, UnsignedInteger16bits& absoluteYearSinceTheBirthOfJisus );


	// Method Information :
	//
	//  Description :
	//
	//		Use this method to get a date and time stamp
	//
	//  Required arguments :
	//
	//		User information needed :
	//
    //          1. second - a reference to a byte that will store the value read for the seconds part of the time
    //          2. minute - a reference to a byte that will store the value read for the minutes part of the time
    //          3. hour - a reference to a byte that will store the value read for the hour part of the time
    //          4. dayOfMonth - a reference to a byte that will store the value read for the day of month part of the date
    //          5. month - a reference to a byte that will store the value read for the month part of the date
    //          6. absoluteYearSinceTheBirthOfJisus - a reference to two bytes that will store the value read for the year part of the date
	//
	//		Information returned to the user :
	//
	//			NONE
	//
	//  Return value :
	//
	//		NONE
	//
	//  Expectations :
	//
    //      NONE
	//
	//  Possible errors :
	//
	//		NONE
	//
	static void DateAndTimeStamp( UnsignedInteger8bits& dayOfMonth, UnsignedInteger8bits& month, UnsignedInteger16bits& absoluteYearSinceTheBirthOfJisus, UnsignedInteger8bits& second, UnsignedInteger8bits& minute, UnsignedInteger8bits& hour );


	DEBUG_TOOL(

		// This part of the object is dedicated for testing :


		// Method Information :
		//
		//  Description :
		//
		//		This method is used to test the object. It is not part of the implementation, it is only used to find problems with the code
		//
		//  Required arguments :
		//
		//		User information needed :
		//
		//			NONE
		//
		//		Information returned to the user :
		//
		//			NONE
		//
		//  Return value :
		//
		//			NONE
		//
		//  Expectations :
		//
		//		Please let the test pass lord!!
		//
		//  Possible errors :
		//
		//		It says there are no problems, which is even scarier, did I just wrote a working code??
		//
		static void UnitTest() __attribute__ (( __unused__ ));

	)  //  End of debug tool


private:


	// Disable all default generated methods - constructor, destructor, copy constructor, assignment operator, move constructor and move assignment operator
	NoInstances( RealTimeClock );


	// Static data members do not belong to any instance, they belong to the object. Like every global variable it is created with the
	// start of the program and only destroyed when the program ends. The access to the static member is bound to this object of course


	// This object will store the bytes format of the real time clock hardware device registers. There are 4 possible formats :
	//
	//		* Binary or binary coded decimal mode
	//		* Hours in 12 hour format or 24 hour format
	//
	//		Bit position 				Interpretation
	//
	//		7 							Enable cycle update
	//		6 							Enable periodic interrupt
	//		5 							Enable alarm interrupt
	//		4 							Enable update end interrupt
	//		3 							Enable square wave output
	//		2 							Date mode : 0 - binary coded decimal ( BCD ) / 1 - Binary
	//		1 							12/24 hour mode : 0 - 12 hour / 1 - 24 hour
	//		0 							Day light saving enabled : 1 enabled / 0 disabled
	//
	static UnsignedInteger8bits member_statusRegisters_B;

	// This object will store the current century, as not all real time clocks hardware device, contains this information. If the
	// information exist it will be used, otherwise the century will be taken from this object. It should be changed when the next
	// century starts
	static UnsignedInteger16bits member_century;


	// The following methods are private. This means that only public or protected methods can use them, in other words they not part of
	// the interface, but rather help implement it :


	// Method Information :
	//
	//  Description :
	//
	//		Use this method to determine the real time clock hardware device registes byte format
	//
	//  Required arguments :
	//
	//		User information needed :
	//
	//			NONE
	//
	//		Information returned to the user :
	//
	//			NONE
	//
	//  Return value :
	//
	//		A byte that can contain the following values :
	//
	//			0x00 - if the format is binary coded decimal and 12 hour
	//			0x02 - if the format is binary coded decimal and 24 hour
	//			0x04 - if the format is binary and 12 hour
	//			0x06 - if the format is binary and 24 hour
	//
	//  Expectations :
	//
	//		1. The real time clock device exist
	//		2. 
	//
	//  Possible errors :
	//
	//		NONE
	//
	EnsureRetrunValueIsUsed static inline UnsignedInteger8bits SetRegistersByteFormat__Private();


	// Method Information :
	//
	//  Description :
	//
	//		Use this method to determine the real time clock hardware device registes byte format, and convert the second, minute and hour
	//		to binary format if needed. Finally convert the hour to 24 hour format if needed
	//
	//  Required arguments :
	//
	//		User information needed :
	//
	//			second - a reference to the variable that contains the second part of the time
	//			minute - a reference to the variable that contains the minute part of the time
	//			hour - a reference to the variable that contains the hour part of the time
	//
	//		Information returned to the user :
	//
	//			NONE
	//
	//  Return value :
	//
	//		NONE
	//
	//  Expectations :
	//
	//		NONE
	//
	//  Possible errors :
	//
	//		NONE
	//
	static void ConvertIfNeededToBinaryFormatAndTwentyFourHourFormat__Private( UnsignedInteger8bits& second, UnsignedInteger8bits& minute, UnsignedInteger8bits& hour );


	// Method Information :
	//
	//  Description :
	//
	//		Use this method to determine the real time clock hardware device registes byte format, and convert the day of month, month and
	//		year to binary format if needed. It will also convert the year to the absolute year since the birth of jisus
	//
	//  Required arguments :
	//
	//		User information needed :
	//
	//			dayOfMonth - a reference to the variable that contains the day of month part of the time
	//			month - a reference to the variable that contains the month part of the time
	//			year - a reference to the variable that contains the year part of the time
	//			century - a reference to the variable that contains the century part of the time
	//
	//		Information returned to the user :
	//
	//			NONE
	//
	//  Return value :
	//
	//		NONE
	//
	//  Expectations :
	//
	//		NONE
	//
	//  Possible errors :
	//
	//		NONE
	//
	static void ConvertIfNeededToBinaryFormatAndSetAbsoluteYearSinceThenBirthOfJisus__Private( UnsignedInteger8bits& dayOfMonth, UnsignedInteger8bits& month, UnsignedInteger16bits& year, UnsignedInteger8bits& century );


};  //  Class RealTimeClock